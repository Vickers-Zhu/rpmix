#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const glob = require("glob");
const { program } = require("commander");
const { parse } = require("@babel/parser");
const traverse = require("@babel/traverse").default;

// Configuration management
let config = {
  alwaysInclude: [],
  ignore: [],
  outputFile: "repomix-bundle.txt",
  maxDepth: 5,
  verbose: false,
};

// Try to load config from repomix.config.js if it exists
function loadConfig() {
  const configPath = path.join(process.cwd(), "repomix.config.js");
  if (fs.existsSync(configPath)) {
    try {
      const userConfig = require(configPath);
      config = { ...config, ...userConfig };
      if (config.verbose) {
        console.log("Loaded configuration from repomix.config.js");
      }
    } catch (err) {
      console.error("Error loading configuration:", err);
    }
  }
}

// Parse command line arguments
program
  .name("rpmix")
  .description(
    "Bundle relevant parts of a codebase based on directory analysis"
  )
  .version("1.0.0")
  .argument("[directories...]", "Directories to analyze", ["server/actions"])
  .option("-o, --output <file>", "Output file name", "repomix-bundle.txt")
  .option(
    "-i, --include <dirs...>",
    "Directories to always include (comma-separated)"
  )
  .option(
    "-x, --exclude <dirs...>",
    "Directories/patterns to exclude (comma-separated)"
  )
  .option("-d, --depth <number>", "Maximum import depth to follow", parseInt)
  .option("-v, --verbose", "Verbose output")
  .action((directories, options) => {
    // Load config file first
    loadConfig();

    // Command line options override config file
    if (options.output) config.outputFile = options.output;
    if (options.include)
      config.alwaysInclude = options.include.join(",").split(",");
    if (options.exclude) config.ignore = options.exclude.join(",").split(",");
    if (options.depth) config.maxDepth = options.depth;
    if (options.verbose) config.verbose = true;

    // Convert directories to a glob pattern that recursively includes all files
    let entryPattern;
    if (directories.length === 0) {
      // Default if no directories provided
      entryPattern = "server/actions/**/*.{js,jsx,ts,tsx}";
    } else if (directories.length === 1) {
      // Single directory - check if it's a directory or a file/pattern
      const dir = directories[0];
      if (fs.existsSync(dir) && fs.statSync(dir).isDirectory()) {
        entryPattern = `${dir}/**/*.{js,jsx,ts,tsx}`;
      } else {
        // Assume it's already a pattern
        entryPattern = dir;
      }
    } else {
      // Multiple directories
      const patterns = directories.map((dir) => {
        if (fs.existsSync(dir) && fs.statSync(dir).isDirectory()) {
          return `${dir}/**/*.{js,jsx,ts,tsx}`;
        }
        return dir;
      });
      entryPattern = `{${patterns.join(",")}}`;
    }

    if (config.verbose) {
      console.log(`Using entry pattern: ${entryPattern}`);
    }

    // Run the bundler
    bundle(entryPattern);
  });

program.parse();

// Main bundling function
async function bundle(entryPattern) {
  if (config.verbose) {
    console.log(
      "Starting bundling with config:",
      JSON.stringify(config, null, 2)
    );
    console.log(`Entry pattern: ${entryPattern}`);
  }

  // Track processed files to avoid duplicates
  const processedFiles = new Set();

  // Final bundle content
  let bundleContent = `// Generated by rpmix on ${new Date().toISOString()}\n\n`;

  // Define code file extensions
  const codeExtensions = [
    ".js",
    ".jsx",
    ".ts",
    ".tsx",
    ".mjs",
    ".cjs", // JavaScript/TypeScript
    ".json",
    ".md",
    ".mdx", // Config/Documentation
    ".css",
    ".scss",
    ".less", // Styles (could be important for frontend)
    ".html",
    ".xml",
    ".svg", // Markup
    ".graphql",
    ".gql", // GraphQL
    ".yaml",
    ".yml", // YAML configs
  ];

  // Process always-include directories/files first
  for (const includeItem of config.alwaysInclude) {
    // Check if it's a directory and convert to glob pattern if needed
    let pattern = includeItem;
    if (fs.existsSync(includeItem) && fs.statSync(includeItem).isDirectory()) {
      // Only include code files, not media
      pattern = `${includeItem}/**/*{${codeExtensions.join(",")}}`;
      if (config.verbose) {
        console.log(
          `Converting directory "${includeItem}" to pattern "${pattern}"`
        );
      }
    }

    const files = glob.sync(pattern, { ignore: config.ignore });
    if (config.verbose) {
      console.log(
        `Found ${files.length} files in always-include item "${includeItem}"`
      );
    }

    for (const file of files) {
      // Skip media files and other binary files
      const ext = path.extname(file).toLowerCase();
      if (!codeExtensions.includes(ext)) {
        if (config.verbose) {
          console.log(`Skipping non-code file: ${file}`);
        }
        continue;
      }

      if (config.verbose) {
        console.log(`Including always-include file: ${file}`);
      }
      const content = await processFile(file);
      if (content) {
        bundleContent += `// File: ${file}\n${content}\n\n`;
        processedFiles.add(path.resolve(file));
      }
    }
  }

  // Find all files matching the entry pattern
  const entryFiles = glob.sync(entryPattern, { ignore: config.ignore });
  if (config.verbose) {
    console.log(`Found ${entryFiles.length} files matching the entry pattern`);
  }

  if (entryFiles.length === 0) {
    console.warn(`Warning: No files found matching "${entryPattern}"`);
  }

  // Process all entry files and their dependencies
  for (const file of entryFiles) {
    // Skip directories explicitly, though glob should only return files
    if (fs.statSync(file).isDirectory()) {
      if (config.verbose) {
        console.log(`Skipping directory: ${file}`);
      }
      continue;
    }

    // Skip non-JS/TS files for import analysis
    const ext = path.extname(file).toLowerCase();
    if (![".js", ".jsx", ".ts", ".tsx", ".mjs", ".cjs"].includes(ext)) {
      if (config.verbose) {
        console.log(`Skipping non-JS/TS file for import analysis: ${file}`);
      }
      continue;
    }

    if (config.verbose) {
      console.log(`Processing entry file: ${file}`);
    }

    if (!processedFiles.has(path.resolve(file))) {
      const content = await processFile(file);
      if (content) {
        bundleContent += `// File: ${file}\n${content}\n\n`;
        processedFiles.add(path.resolve(file));

        // Now process its dependencies
        bundleContent = await processImports(
          file,
          processedFiles,
          bundleContent
        );
      }
    }
  }

  // Write the final bundle
  fs.writeFileSync(config.outputFile, bundleContent);
  console.log(
    `Bundle created at ${config.outputFile} with ${processedFiles.size} code files`
  );
}

// Process a file's imports recursively
async function processImports(
  filePath,
  processedFiles,
  bundleContent,
  currentDepth = 0
) {
  if (currentDepth > config.maxDepth) {
    if (config.verbose) {
      console.log(
        `Reached maximum depth (${config.maxDepth}) at ${filePath}, stopping recursion`
      );
    }
    return bundleContent;
  }

  const resolvedPath = path.resolve(filePath);

  // Skip if it's in the ignore list
  if (isIgnored(resolvedPath)) {
    return bundleContent;
  }

  try {
    // Read the file
    const fileContent = fs.readFileSync(resolvedPath, "utf-8");

    // Find imports
    const imports = extractImports(resolvedPath, fileContent);

    if (config.verbose) {
      console.log(`Found ${imports.length} imports in ${filePath}`);
    }

    // Process each import recursively
    for (const importPath of imports) {
      // Skip if we've already processed this file
      if (processedFiles.has(path.resolve(importPath))) {
        continue;
      }

      if (config.verbose) {
        console.log(
          `Processing import: ${importPath} (depth: ${currentDepth + 1}/${
            config.maxDepth
          })`
        );
      }

      const content = await processFile(importPath);
      if (content) {
        bundleContent += `// File: ${importPath}\n${content}\n\n`;
        processedFiles.add(path.resolve(importPath));

        // Process this import's dependencies
        bundleContent = await processImports(
          importPath,
          processedFiles,
          bundleContent,
          currentDepth + 1
        );
      }
    }
  } catch (err) {
    console.error(`Error processing imports in ${filePath}:`, err);
  }

  return bundleContent;
}

// Extract import paths from a file
function extractImports(filePath, content) {
  const imports = [];
  const fileDir = path.dirname(filePath);

  try {
    // Parse the file
    const ast = parse(content, {
      sourceType: "module",
      plugins: ["jsx", "typescript", "decorators-legacy", "classProperties"],
    });

    // Traverse the AST to find imports
    traverse(ast, {
      ImportDeclaration({ node }) {
        const importPath = node.source.value;

        // Skip node_modules and absolute imports
        if (importPath.startsWith(".") || !importPath.includes("/")) {
          // Resolve the import path relative to the current file
          const resolvedPath = resolveImportPath(fileDir, importPath);
          if (resolvedPath) {
            imports.push(resolvedPath);
          }
        }
      },
      CallExpression({ node }) {
        // Handle require() calls
        if (
          node.callee.name === "require" &&
          node.arguments.length > 0 &&
          node.arguments[0].type === "StringLiteral"
        ) {
          const importPath = node.arguments[0].value;

          // Skip node_modules and absolute imports
          if (importPath.startsWith(".") || !importPath.includes("/")) {
            const resolvedPath = resolveImportPath(fileDir, importPath);
            if (resolvedPath) {
              imports.push(resolvedPath);
            }
          }
        }
      },
    });
  } catch (err) {
    console.error(`Error parsing ${filePath}:`, err);
  }

  return imports;
}

// Resolve an import path to a filesystem path
function resolveImportPath(baseDir, importPath) {
  // List of possible extensions to try
  const extensions = [".ts", ".tsx", ".js", ".jsx", ".json"];

  // If import path already has an extension, try that first
  if (path.extname(importPath)) {
    const filePath = path.resolve(baseDir, importPath);
    if (fs.existsSync(filePath)) {
      return filePath;
    }
  }

  // Try each extension
  for (const ext of extensions) {
    const filePath = path.resolve(baseDir, importPath + ext);
    if (fs.existsSync(filePath)) {
      return filePath;
    }
  }

  // Try index files in directory
  for (const ext of extensions) {
    const indexPath = path.resolve(baseDir, importPath, `index${ext}`);
    if (fs.existsSync(indexPath)) {
      return indexPath;
    }
  }

  if (config.verbose) {
    console.warn(`Could not resolve import: ${importPath} from ${baseDir}`);
  }

  return null;
}

// Check if a file should be ignored
function isIgnored(filePath) {
  return config.ignore.some((pattern) => {
    // Convert glob pattern to regex
    const regexPattern = pattern
      .replace(/\./g, "\\.")
      .replace(/\*/g, ".*")
      .replace(/\?/g, ".");

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(filePath);
  });
}

// Process a file
async function processFile(filePath) {
  try {
    const ext = path.extname(filePath).toLowerCase();

    // Skip binary and media files
    const binaryExtensions = [
      ".png",
      ".jpg",
      ".jpeg",
      ".gif",
      ".bmp",
      ".tiff",
      ".webp", // Images
      ".mp3",
      ".wav",
      ".ogg",
      ".flac",
      ".aac", // Audio
      ".mp4",
      ".avi",
      ".mov",
      ".wmv",
      ".flv",
      ".webm", // Video
      ".pdf",
      ".doc",
      ".docx",
      ".xls",
      ".xlsx",
      ".ppt",
      ".pptx", // Documents
      ".zip",
      ".tar",
      ".gz",
      ".7z",
      ".rar", // Archives
      ".exe",
      ".dll",
      ".so",
      ".dylib", // Binaries
      ".ttf",
      ".otf",
      ".woff",
      ".woff2", // Fonts
      ".ico",
      ".cur", // Icons
    ];

    if (binaryExtensions.includes(ext)) {
      if (config.verbose) {
        console.log(`Skipping binary/media file: ${filePath}`);
      }
      return null;
    }

    // For text files, read content
    return fs.readFileSync(filePath, "utf-8");
  } catch (err) {
    console.error(`Error reading ${filePath}:`, err);
    return null;
  }
}
